<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>_mike - Customizable Datatypes</title>
        <link rel="stylesheet" type="text/css" href="../style.css" />
    </head>
    <body>
        <header>
            <a id="logo" href="../">
                <img src="../images/profile.png" height="32px" />
                _mike
            </a>
            <nav>
                <a href="../cv.pdf">CV</a>
                <a href="../about.html">About</a>
                <a href="../atom.xml">
                    <img class="inline-icon" alt="Feed" src="../images/fa-rss-solid.svg" />
                </a>
            </nav>
        </header>

        <article>
            <h1 class="page-title">Customizable Datatypes</h1>

            Posted on <time>August 23, 2019</time>

<p>This post is based on a post here: <a href="https://mazzo.li/posts/customizable-data-types.html">https://mazzo.li/posts/customizable-data-types.html</a> I suggest reading that post first. It’s a very short (but quite interesting) read. I will, however, give a quick summary here.</p>
<p>I recently decided to use this pattern on my pet language project, Kima. I had a problem with the number of parameters on my AST type getting out of hand. I have to make multiple changes to it on the way from parsing to interpretation/compilation and so it needs to be heavily parameterized, nodes have to be enabled/disabled, etc. This pattern allows parameters to be added in an easy way without cluttering up type signatures and has helped clean up a lot of code.</p>
<p>The code here will require the following GHC extensions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span></code></pre></div>
<h1 id="original-article">Original article</h1>
<p>Essentially, the author describes a way to reduce the number of type parameters to a data type to a single “index” type parameter. They do that by introducing a single “index” type parameter as well as a set of type families which operate on that “index”.</p>
<p>So for example, this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">ExprBasic</span> hasIf var <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="dt">IfBasic</span><span class="ot"> ::</span> <span class="dt">ExprBasic</span> <span class="dt">'True</span> var <span class="ot">-&gt;</span> <span class="dt">ExprBasic</span> <span class="dt">'True</span> var <span class="ot">-&gt;</span> <span class="dt">ExprBasic</span> <span class="dt">'True</span> var</span>
<span id="cb2-3"><a href="#cb2-3"></a>        <span class="ot">-&gt;</span> <span class="dt">ExprBasic</span> <span class="dt">'True</span> var</span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="dt">VarBasic</span><span class="ot"> ::</span> var</span>
<span id="cb2-5"><a href="#cb2-5"></a>        <span class="ot">-&gt;</span> <span class="dt">ExprBasic</span> hasIf var</span></code></pre></div>
<p>becomes this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- Full path to a name</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">newtype</span> <span class="dt">QualName</span> <span class="ot">=</span> <span class="dt">QualName</span> [<span class="dt">String</span>]</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">data</span> <span class="dt">Parsed</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">data</span> <span class="dt">Renamed</span></span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Var</span><span class="ot"> idx ::</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="dt">Var</span> <span class="dt">Parsed</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="dt">Var</span> <span class="dt">Renamed</span> <span class="ot">=</span> <span class="dt">QualName</span></span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">HasIf</span><span class="ot"> idx ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="dt">HasIf</span> <span class="dt">Parsed</span> <span class="ot">=</span> <span class="dt">'True</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>    <span class="dt">HasIf</span> <span class="dt">Renamed</span> <span class="ot">=</span> <span class="dt">'True</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">-- Maybe some later stage desugars ifs into something else</span></span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="kw">data</span> <span class="dt">Expr</span> idx <span class="kw">where</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="dt">If</span><span class="ot"> ::</span> <span class="dt">HasIf</span> idx <span class="op">~</span> <span class="dt">'True</span> <span class="ot">=&gt;</span> <span class="dt">Expr</span> idx <span class="ot">-&gt;</span> <span class="dt">Expr</span> idx <span class="ot">-&gt;</span> <span class="dt">Expr</span> idx <span class="ot">-&gt;</span> <span class="dt">Expr</span> idx</span>
<span id="cb3-18"><a href="#cb3-18"></a>  <span class="dt">Var</span><span class="ot"> ::</span> <span class="dt">Var</span> idx <span class="ot">-&gt;</span> <span class="dt">Expr</span> idx</span></code></pre></div>
<h1 id="benefits">Benefits</h1>
<p>Obviously the second version is a lot more code but it does allow for some interesting differences from the first.</p>
<ol>
<li><p>If we add a parameter to <code>Expr</code> we don’t have to change every signature where that type appears.</p></li>
<li><p>I would argue that it shows intent a lot better than the original. Compare</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">f ::</span> <span class="dt">Expr</span> <span class="dt">Parsed</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Renamed</span></span></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">f ::</span> <span class="dt">Expr</span> <span class="dt">'True</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">'True</span> <span class="dt">QualName</span></span></code></pre></div>
<p>You could type synonyms to make the second look more like the first, and it would make the type signatures a lot cleaner but they won’t show up in error messages, where you will have to decypher what each type parameter means.</p></li>
<li><p>With the closed type families used in the example, we can clearly enumerate all the possible configurations our Expr type could be in.</p></li>
</ol>
<h1 id="using-associated-type-families">Using associated type families</h1>
<p>The way I use this pattern is a little different from the original is in how I use type families. The original article used closed type families. I have a few problems with this choice.</p>
<ul>
<li>It doesn’t allow adding more stages (although the author does suggest using open type families which would fix this)</li>
<li>It doesn’t give a compiler warning if a stage has some necessary variable missing. This will give cryptic errors in the form <code>Var t does not equal
 String</code>, <strong>at the call site</strong> because of the way type families are evaluated.</li>
<li>It spreads out the definition of each data type across type family definitions (This could also be fixed by using open type families)</li>
</ul>
<p>We can fix all of the above by grouping all the type families into a typeclass as associated types like so:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">class</span> <span class="dt">ExprIndex</span> idx <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="kw">type</span> <span class="dt">Var</span><span class="ot"> idx ::</span> <span class="op">*</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="kw">type</span> <span class="dt">HasIf</span><span class="ot"> idx ::</span> <span class="dt">Bool</span></span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">instance</span> <span class="dt">ExprIndex</span> <span class="dt">Parsed</span> <span class="kw">where</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>  <span class="kw">type</span> <span class="dt">Var</span> <span class="dt">Parsed</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>  <span class="kw">type</span> <span class="dt">HasIf</span> <span class="dt">Parsed</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="kw">instance</span> <span class="dt">ExprIndex</span> <span class="dt">Renamed</span> <span class="kw">where</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>  <span class="kw">type</span> <span class="dt">Var</span> <span class="dt">Parsed</span> <span class="ot">=</span> <span class="dt">QualName</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>  <span class="kw">type</span> <span class="dt">HasIf</span> <span class="dt">Parsed</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>I find this much more pleasing to read and it also gives a warning if we miss a a definition for one of the indices.</p>
<h1 id="warning-prefer-concrete-types">Warning: Prefer concrete types!</h1>
<p>When I first started with this pattern, I tried using polymorphic functions, and only constraining the parameters that would be transformed. For example:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>rename</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">  ::</span> (<span class="dt">Var</span> idx2 <span class="op">~</span> <span class="dt">QualName</span>, <span class="dt">HasIf</span> idx1 <span class="op">~</span> <span class="dt">HasIf</span> idx2)</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="ot">=&gt;</span> <span class="dt">Expr</span> idx1 <span class="ot">-&gt;</span> <span class="dt">Expr</span> idx2</span>
<span id="cb7-4"><a href="#cb7-4"></a>rename expr <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>This style works ok for traversals and other simple functions that have no intermediate stages, but in more complicated transformations type inference can be an issue. There will very often be errors involving ambiguous type variables or unresolved type families. Therefore, I suggest leaving the polymorphic types for the functions that will be widely used throughout your application (like traversals) and prefering monomorphic types wherever possible elsewhere.</p>

        </article>
        <footer>
            <span id="netlify-footer">
                Hosted on <a href="https://netlify.com">Netlify</a>
            </span>
            <span id="gitlab-footer">
                Source code on <a href="https://gitlab.com/michalis_pardalos/_mike">Gitlab</a>
            </span>
            <span id="hakyll-footer">
                Site proudly generated by
                <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            </span>
            <span id="fontawesome-footer">
                This site uses icons from 
                <a href="https://fontawesome.com">FontAwesome</a> &mdash;
                <a href="https://fontawesome.com/license">License</a>
            </span>
        </footer>
    </body>
</html>
